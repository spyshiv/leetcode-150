# Group Anagrams

The **Group Anagrams** problem is a classic question that tests your understanding of **hashing**, **string manipulation**, and **data grouping**. It’s frequently asked in coding interviews for its algorithmic insight and real-world applications like grouping similar data points.

In this article, we’ll break down the **problem**, walk through the **best approach**, and provide **JavaScript solutions** with time and space complexity analysis.

---

## 🔍 Problem Statement

Given an array of strings `strs`, group the anagrams together. You can return the answer in **any order**.

### Anagram Reminder:

Two strings are anagrams if they contain the **same characters in the same frequency**, but possibly in a different order.

### Examples:

```js
groupAnagrams(["eat","tea","tan","ate","nat","bat"]);
// Output: [["eat","tea","ate"],["tan","nat"],["bat"]]

groupAnagrams([""]);
// Output: [[""]]

groupAnagrams(["a"]);
// Output: [["a"]]
```

---

## 🧩 Understanding the Algorithm

The key idea is to **group words with the same character frequency** together. For example, `"eat"`, `"tea"`, and `"ate"` are all anagrams because they all contain 1 `'e'`, 1 `'a'`, and 1 `'t'`.

To group them:

-   Sort each word alphabetically and use that as a **key**.

-   Use a **hash map** to collect all words with the same sorted key.


---

## ✅ JavaScript Solution using Hash Map and Sorted Key

This is the most efficient and commonly used solution:

```js
/**
 * Groups anagrams from a list of strings.
 * @param {string[]} strs - List of strings
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
    const map = new Map();

    for (let str of strs) {
        // Sort the string to create a unique key
        const sorted = str.split('').sort().join('');

        // Push to the correct group
        if (!map.has(sorted)) {
            map.set(sorted, []);
        }
        map.get(sorted).push(str);
    }

    return Array.from(map.values());
};
```

---

## 🕒 Time & Space Complexity

-   **Time Complexity:** O(n * k log k)

    -   `n` = number of strings

    -   `k` = max length of a string (because sorting each string takes O(k log k))

-   **Space Complexity:** O(n * k)

    -   Storing `n` strings in the map, each of length up to `k`.


---

## 📌 Notes & Gotchas

-   ✅ **Sorting as a Key:** Sorting gives a unique and consistent signature for anagrams.

-   ❌ **Don’t Use Frequency Alone in Objects (unless optimized):** Counting characters with objects is also valid but usually more verbose and less intuitive than sorting.

-   ✅ **Stable Grouping:** The output order doesn’t matter, but the groupings must be correct.

-   ✅ **Empty Strings:** Should be grouped as anagrams as well.


---

## ⏱ Complexity Analysis Summary

| Approach | Time Complexity | Space Complexity |
| --- | --- | --- |
| Sort-based Key + Hash Map | O(n * k log k) | O(n * k) |

---

## 🔗 Reference

[Leetcode: Group Anagrams](https://leetcode.com/problems/group-anagrams/)
